
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>CPG Code Documentation</title>
    <meta name="author" content="">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {background-color: white; padding-left: 260px; padding-right: 260px;}
        h1, h2, h3, h4, h5, h6   {color: darkslateblue; font-family: sans-serif;}
        p, dl {color: black; font-family: sans-serif;}
        dt, dd {margin-top: 10px;}
        code {color: black; background-color: #f1f1f1;}
        pre {background-color: #f1f1f1; padding-left: 20px; padding-right: 20px;}
    </style>
</head>

<body>
  <h1>C code to solve your CVXPY problem</h1>
  <h3>File tree</h3>
  <p>
    Your generated code is structured as follows inside your chosen <code>$CODEDIR</code> directory:
  </p>
  <pre><code><!-- language: lang-c -->
$CODEDIR
    c
      OSQP_code
        ...
      include
        cpg_workspace.h
        cpg_solve.h
      src
        cpg_workspace.c
        cpg_solve.c
        cpg_example.c
      build
      CMakeLists.txt
    cpp
      include
        cpg_module.hpp
      src
        cpg_module.cpp
    setup.py
    cpg_solver.py
    problem.pickle
  </code></pre>
  <p>
      The <code>c/OSQP_code</code> subdirectory contains all code produced by the code generation feature of the chosen
      numerical solver (OSQP). For documentation on this part, please have a look <a href="https://osqp.org/docs/codegen/python.html" target="_blank">here</a>.
  </p>
  <p>
    To make this solver usable, your problem needs to be converted to the standard form accepted by OSQP.
      This is done by all the other source files inside the <code>$CODEDIR</code> directory.
  </p>
  <h3>Types, declarations & definitions</h3>

  <p>
    <dl>
      <dt><code>c/include/cpg_workspace.h</code> contains type definitions,</dt>
        <dd>
          <pre><code><!-- language: lang-c -->
// Struct type with OSQP-accepted parameters as fields
typedef struct {
    csc         *P;              ///< OSQP parameter P
    c_float     *q;              ///< OSQP parameter q
    c_float     *d;              ///< OSQP parameter d
    csc         *A;              ///< OSQP parameter A
    c_float     *l;              ///< OSQP parameter l
    c_float     *u;              ///< OSQP parameter u
} OSQP_Params_t;

// Struct type with booleans as fields, indicating if respective OSQP parameter is outdated
typedef struct {
    int         P;              ///< bool, if OSQP parameter P outdated
    int         q;              ///< bool, if OSQP parameter q outdated
    int         d;              ///< bool, if OSQP parameter d outdated
    int         A;              ///< bool, if OSQP parameter A outdated
    int         l;              ///< bool, if OSQP parameter l outdated
    int         u;              ///< bool, if OSQP parameter u outdated
} OSQP_Outdated_t;
$CPGPARAMSTYPEDEF
// Struct type with user-defined objective value and solution as fields
$CPGRESULTTYPEDEF
          </code></pre>
        </dd>
        <dd>
             and C variable declarations, where matrix parameters and variables are stored in vectorized form:
        </dd>
        <dd>
          <pre><code><!-- language: lang-c -->
// Struct containing flags for outdated OSQP parameters
OSQP_Outdated_t OSQP_Outdated;

// Parameters accepted by OSQP
csc P;
c_float q[11];
c_float d;
csc A;
c_float l[15];
c_float u[15];

// Struct containing parameters accepted by OSQP
OSQP_Params_t OSQP_Params;

// User-defined parameters
$CPGPARAMDECLARATIONS

// Value of the objective function
c_float objective_value;

// User-defined variables
$CPGVARIABLEDECLARATIONS

// Struct containing user-defined objective value and solution
CPG_Result_t CPG_Result;
          </code></pre>
        </dd>
      <dt><code>c/include/cpg_solve.h</code> contains function prototypes:</dt>
        <dd>
          <pre><code><!-- language: lang-c -->
// map user-defined to OSQP-accepted parameters
void canonicalize_OSQP_P();
void canonicalize_OSQP_q();
void canonicalize_OSQP_d();
void canonicalize_OSQP_A();
void canonicalize_OSQP_l();
void canonicalize_OSQP_u();

// retrieve user-defined objective function value
void retrieve_value();

// retrieve solution in terms of user-defined variables
void retrieve_solution();

// perform one ASA sequence to solve a problem instance
void solve();

// update user-defined parameter values
$CPGUPDATEDECLARATIONS

// update OSQP settings
void set_OSQP_default_settings();
void set_OSQP_&lt;setting_name&gt;(&lt;setting_type&gt; &lt;setting_value&gt;);
...
          </code></pre>
        </dd>
        <dd>
            where <code>&lt;setting_name&gt;</code>, <code>&lt;setting_type&gt;</code>, and <code>&lt;setting_value&gt;</code> are
            the name, type, and value of the OSQP setting to be updated, respectively.
        </dd>
      <dt><code>c/src/cpg_workspace.c</code> contains the static allocation of the C variables declared in <code>include/cpg_workspace.h</code>.</dt>
      <dt><code>c/src/cpg_solve.c</code> contains the definition of functions declared in <code>include/cpg_solve.h</code>.</dt>
      <dt><code>c/src/cpg_example.c</code> contains example code that initializes the problem data and solves a problem instance.</dt>
      <dt><code>c/CMakeLists.txt</code> contains instructions for build file generation inside the <code>c/build</code> directory with CMake.</dt>
      <dt><code>cpp/</code> contains binding code for the python wrapper generated with <a href="https://github.com/pybind/pybind11" target="_blank">pybind11</a> and <code>setup.py</code>.</dt>
      <dt><code>cpg_solver.py</code> contains a custom CVXPY solve method that uses the python wrapper to solve your problem.</dt>
      <dt>Finally, <code>problem.pickle</code> is the serialized version of your CVXPY problem object.</dt>
    </dl>
  </p>

  <h3>Using Generated Code</h3>

  <h4>Python</h4>

  <p>
      To use the python module, run exemplarily,
  </p>
    <pre><code>
import pickle
from $CDPYTHON.cpg_solver import cpg_solve

with open('$CODEDIR/problem.pickle', 'rb') as f:
    prob = pickle.load(f)

prob.param_dict['&lt;p_name&gt;'].value = &lt;p_value&gt;
prob.register_solve('CPG', cpg_solve)

obj = prob.solve(method='CPG')
print(prob.var_dict['&lt;v_name&gt;'].value)
    </code></pre>
  <p>where <code>&lt;p_name&gt;</code> and <code>&lt;p_value&gt;</code> are parameter name and value, respectively.
  After registering <code>&lt;cpg_solve&gt;</code> as custom solve method, the problem can be solved and the objective value
  <code>obj</code> and solution in terms of variable <code>&lt;v_name&gt;</code> can be inspected.
  </p>

  <h4>Example Executable</h4>

  <p>
    To compile the example executable on a Unix platform, run the following:
  </p>
    <pre><code>
cd $CODEDIR/c/build
cmake ..
make
    </code></pre>

  <p>
    To run the example executable, type:
  </p>
    <pre><code>
$CODEDIR/c/build/cpg_example
    </code></pre>

  <h4>Existing Project</h4>

  <p>
    To use the generated code in an existing <code>CMake</code> project, copy the following to a subdirectory <code>&lt;subdir&gt;</code>
      of your project:
  </p>
    <pre><code>
$CODEDIR/c/CMakeLists.txt
$CODEDIR/c/src/
$CODEDIR/c/include/
$CODEDIR/c/OSQP_code/
    </code></pre>

  <p>
    In your top-level <code>CMakeLists.txt</code>, add the subdirectory via
  </p>
    <pre><code>
add_subdirectory(&lt;subdir&gt;)
include_directories(&lt;existing_dirs&gt; &lt;subdir&gt;/include &lt;subdir&gt;/OSQP_code/include)
    </code></pre>
  <p>
      where <code>&lt;existing_dirs&gt;</code> is your existing include directories, and add <code>${cpg_src}</code>
      to all targets that use the generated code.
  </p>

</body>

</html>
