"""
Copyright 2022 Maximilian Schaller
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import numpy as np
from datetime import datetime


def write_vec_def(f, vec, name, typ):
    """
    Write vector to file
    """
    f.write('%s %s[%d] = {\n' % (typ, name, len(vec)))

    # Write vector components
    for i in range(len(vec)):
        if typ == 'cpg_float':
            f.write('(cpg_float)%.20f,\n' % vec[i])
        else:
            f.write('%i,\n' % vec[i])

    f.write('};\n')


def write_vec_prot(f, vec, name, typ):
    """
    Write vector to file
    """
    f.write('extern %s %s[%d];\n' % (typ, name, len(vec)))


def write_mat_def(f, mat, name):
    """
    Write sparse matrix (scipy compressed sparse column) to file
    """
    write_vec_def(f, mat['i'], name + '_i', 'cpg_int')
    write_vec_def(f, mat['p'], name + '_p', 'cpg_int')
    write_vec_def(f, mat['x'], name + '_x', 'cpg_float')

    f.write('cpg_csc %s = {' % name)
    f.write('%d, ' % mat['nzmax'])
    f.write('%d, ' % mat['m'])
    f.write('%d, ' % mat['n'])
    f.write('%s_p, ' % name)
    f.write('%s_i, ' % name)
    f.write('%s_x, ' % name)
    f.write('%d};\n' % mat['nz'])


def write_mat_prot(f, mat, name):
    """
    Write sparse matrix (scipy compressed sparse column) to file
    """
    f.write('extern cpg_csc %s;\n' % name)


def write_dense_mat_def(f, mat, name):
    """
    Write dense matrix to file
    """

    f.write('cpg_float %s[%d] = {\n' % (name, mat.size))

    # represent matrix as vector (Fortran style)
    for j in range(mat.shape[1]):
        for i in range(mat.shape[0]):
            f.write('(cpg_float)%.20f,\n' % mat[i, j])

    f.write('};\n')


def write_dense_mat_prot(f, mat, name):
    """
    Write dense matrix to file
    """

    f.write("extern cpg_float cpg_%s[%d];\n" % (name, mat.size))


def write_description(f, file_type, content):
    """
    Timestamp and file content to beginning of file
    """

    if file_type == 'py':
        comment_str = '"""'
    else:
        comment_str = '/*'
    now = datetime.now()
    f.write('\n%s\n' % comment_str)
    f.write('Auto-generated by CVXPYgen %s.\n' % now.strftime("on %B %d, %Y at %H:%M:%S"))
    f.write('Content: %s.\n' % content)
    f.write('%s\n\n' % comment_str[::-1])


def replace_in_file(filepath, replacements):
    """
    Replace strings in file
    """

    with open(filepath, 'r') as f:
        t = f.read()
    for old, new in replacements:
        t = t.replace(old, new)
    with open(filepath, 'w') as f:
        f.write(t)


def replace_inf(v):
    """
    Replace infinity by large number
    """

    # check if dealing with csc dict or numpy array
    if type(v) == dict:
        sign = np.sign(v['x'])
        idx = np.isinf(v['x'])
        v['x'][idx] = 1e30 * sign[idx]
    else:
        sign = np.sign(v)
        idx = np.isinf(v)
        v[idx] = 1e30 * sign[idx]

    return v


def csc_to_dict(m):
    """
    Convert scipy csc matrix to dict that can be passed to write_mat_def()
    """

    d = dict()
    d['i'] = m.indices
    d['p'] = m.indptr
    d['x'] = m.data
    d['nzmax'] = m.nnz
    (d['m'], d['n']) = m.shape
    d['nz'] = -1

    return d


def param_is_empty(param):
    """
    Check if parameter is empty
    """

    if type(param) == dict:
        return param['x'].size == 0
    else:
        return param.size == 0


def is_mathematical_scalar(x):
    """
    Check if input is a scalar in mathematical sense, e.g., returning True for vectors with length 1
    """

    return True if np.isscalar(x) else x.size == 1


def write_problem_summary(name_to_shape, name_to_size):
    """
    Create html code for param / variables table entries
    """

    string = ''
    for n, sh in name_to_shape.items():
        if sh == ():
            shape_str = '1'
        elif len(sh) == 1:
            shape_str = str(sh[0])
        else:
            shape_str = '%d by %d (%d)' % (sh[0], sh[1], name_to_size[n])
        string += '      <tr>\n        <td><code>%s</code></td>\n        <td>%s</td>\n      </tr>\n' % (n, shape_str)
    return string


def write_canonicalize_explicit(f, p_id, s, mapping, user_p_col_to_name_usp, user_p_name_to_size_usp, prefix):
    """
    Write function to compute canonical parameter value
    """

    sign_to_str = {1: '', -1: '-'}

    for row in range(len(mapping.indptr)-1):
        expr = ''
        expr_is_const = True
        data = mapping.data[mapping.indptr[row]:mapping.indptr[row + 1]]
        columns = mapping.indices[mapping.indptr[row]:mapping.indptr[row + 1]]
        for (datum, col) in zip(data, columns):
            ex = '(%.20f)+' % datum
            for user_p_col, user_name in user_p_col_to_name_usp.items():
                if user_p_col + user_p_name_to_size_usp[user_name] > col:
                    expr_is_const = False
                    if user_p_name_to_size_usp[user_name] == 1:
                        if abs(datum) == 1:
                            ex = '(%s%sCPG_Params.%s)+' % (sign_to_str[datum], prefix, user_name)
                        else:
                            ex = '(%.20f*%sCPG_Params.%s)+' % (datum, prefix, user_name)
                    else:
                        if abs(datum) == 1:
                            ex = '(%s%sCPG_Params.%s[%d])+' % (sign_to_str[datum], prefix, user_name, col - user_p_col)
                        else:
                            ex = '(%.20f*%sCPG_Params.%s[%d])+' % (datum, prefix, user_name, col - user_p_col)
                    break
            expr += ex
        expr = expr[:-1]
        if data.size > 0 and expr_is_const is False:
            if p_id == 'd':
                f.write('  %sCanon_Params.d = %s;\n' % (prefix, expr))
            else:
                f.write('  %sCanon_Params.%s%s[%d] = %s;\n' % (prefix, p_id, s, row, expr))


def write_canonicalize(f, canon_name, s, mapping, prefix):
    """
    Write function to compute canonical parameter value
    """

    f.write('  for(i=0; i<%d; i++){\n' % mapping.shape[0])
    f.write('    %sCanon_Params.%s%s[i] = 0;\n' % (prefix, canon_name, s))
    f.write('    for(j=%scanon_%s_map.p[i]; j<%scanon_%s_map.p[i+1]; j++){\n' %
            (prefix, canon_name, prefix, canon_name))
    f.write('      %sCanon_Params.%s%s[i] += %scanon_%s_map.x[j]*%scpg_params_vec[%scanon_%s_map.i[j]];\n' %
            (prefix, canon_name, s, prefix, canon_name, prefix, prefix, canon_name))
    f.write('    }\n')
    f.write('  }\n')


def write_param_def(f, param, name, prefix, suffix):
    """
    Write vectors and matrices
    """
    if not param_is_empty(param):
        if name.isupper():
            write_mat_def(f, param, '%scanon_%s%s' % (prefix, name, suffix))
        elif name == 'd':
            f.write('cpg_float %scanon_d%s = %.20f;\n' % (prefix, suffix, param[0]))
        else:
            write_vec_def(f, param, '%scanon_%s%s' % (prefix, name, suffix), 'cpg_float')
        f.write('\n')


def write_param_prot(f, param, name, prefix, suffix):
    """
    Write vectors and matrices
    """
    if not param_is_empty(param):
        if name.isupper():
            write_mat_prot(f, param, '%scanon_%s%s' % (prefix, name, suffix))
        elif name == 'd':
            f.write('extern cpg_float %scanon_d%s;\n' % (prefix, suffix))
        else:
            write_vec_prot(f, param, '%scanon_%s%s' % (prefix, name, suffix), 'cpg_float')


def write_struct_def(f, fields, casts, values, name, typ):
    """
    Write structure to file
    """

    f.write('%s %s = {\n' % (typ, name))

    # write structure fields
    for field, cast, value in zip(fields, casts, values):
        if value in ['0', 'SCS_NULL']:
            cast = ''
        f.write('.%s = %s%s,\n' % (field, cast, value))

    f.write('};\n')


def write_struct_prot(f, name, typ):
    """
    Write structure to file
    """

    f.write("extern %s %s;\n" % (typ, name))


def write_ecos_setup_update(f, canon_constants, prefix):
    """
    Write ECOS setup function to file
    """
    n = canon_constants['n']
    m = canon_constants['m']
    p = canon_constants['p']
    ell = canon_constants['l']
    n_cones = canon_constants['n_cones']
    e = canon_constants['e']

    if p == 0:
        Ax_str = Ap_str = Ai_str = b_str = '0'
    else:
        Ax_str = '%sCanon_Params_conditioning.A->x' % prefix
        Ap_str = '%sCanon_Params_conditioning.A->p' % prefix
        Ai_str = '%sCanon_Params_conditioning.A->i' % prefix
        b_str = '%sCanon_Params_conditioning.b' % prefix

    if n_cones == 0:
        ecos_q_str = '0'
    else:
        ecos_q_str = '(int *) &%secos_q' % prefix

    f.write('  if (!%secos_workspace) {\n' % prefix)
    f.write('    %secos_workspace = ECOS_setup(%d, %d, %d, %d, %d, %s, %d, '
            '%sCanon_Params_conditioning.G->x, %sCanon_Params_conditioning.G->p, %sCanon_Params_conditioning.G->i, '
            '%s, %s, %s, %sCanon_Params_conditioning.c, %sCanon_Params_conditioning.h, %s);\n' %
            (prefix, n, m, p, ell, n_cones, ecos_q_str, e, prefix, prefix, prefix, Ax_str, Ap_str, Ai_str,
             prefix, prefix, b_str))
    f.write('  } else {\n')
    f.write('    if (%sCanon_Outdated.G || %sCanon_Outdated.A || %sCanon_Outdated.b) {\n' % (prefix, prefix, prefix))
    f.write('      ECOS_updateData(%secos_workspace, %sCanon_Params_conditioning.G->x, %s, %sCanon_Params_conditioning.c, '
            '%sCanon_Params_conditioning.h, %s);\n' % (prefix, prefix, Ax_str, prefix, prefix, b_str))
    f.write('    } else {\n')
    f.write('      if (%sCanon_Outdated.h) {\n' % prefix)
    f.write('        for (i=0; i<%d; i++){\n' % m)
    f.write('          ecos_updateDataEntry_h(%secos_workspace, i, %sCanon_Params_conditioning.h[i]);\n' % (prefix, prefix))
    f.write('        }\n')
    f.write('      }\n')
    f.write('      if (%sCanon_Outdated.c) {\n' % prefix)
    f.write('        for (i=0; i<%d; i++){\n' % n)
    f.write('          ecos_updateDataEntry_c(%secos_workspace, i, %sCanon_Params_conditioning.c[i]);\n' % (prefix, prefix))
    f.write('        }\n')
    f.write('      }\n')
    f.write('    }\n')
    f.write('  }\n')


def write_workspace_def(f, configuration, variable_info, dual_variable_info, parameter_info, parameter_canon, solver_interface):

    write_description(f, 'c', 'Variable definitions')
    f.write('#include "cpg_workspace.h"\n')

    if configuration.unroll:
        f.write('\n// User-defined parameters\n')
        user_casts = []
        user_values = []
        names = list(parameter_info.writable.keys())
        for name in names:
            value = parameter_info.writable[name]
            if is_mathematical_scalar(value):
                user_casts.append('')
                user_values.append('%.20f' % value)
            else:
                write_vec_def(f, value, configuration.prefix + 'cpg_' + name, 'cpg_float')
                f.write('\n')
                user_casts.append('(cpg_float *) ')
                user_values.append('&' + configuration.prefix + 'cpg_' + name)
        f.write('// Struct containing all user-defined parameters\n')
        write_struct_def(f, names, user_casts, user_values, '%sCPG_Params' % configuration.prefix, 'CPG_Params_t')
        f.write('\n')
    else:
        f.write('\n// Vector containing flattened user-defined parameters\n')
        write_vec_def(f, parameter_info.flat_usp, '%scpg_params_vec' % configuration.prefix, 'cpg_float')
        f.write('\n// Sparse mappings from user-defined to canonical parameters\n')
        for p_id, mapping in parameter_canon.p_id_to_mapping.items():
            if parameter_canon.p_id_to_changes[p_id]:
                write_mat_def(f, csc_to_dict(mapping), '%scanon_%s_map' % (configuration.prefix, p_id))
                f.write('\n')

    p_ids = list(parameter_canon.p.keys())
    canon_casts = []
    f.write('// Canonical parameters\n')
    for p_id in p_ids:
        p = parameter_canon.p[p_id]
        if p_id == 'd':
            canon_casts.append('')
        else:
            write_param_def(f, replace_inf(p), p_id, configuration.prefix, '')
            if solver_interface.inmemory_preconditioning:
                write_param_def(f, replace_inf(p), p_id, configuration.prefix, '_conditioning')
            if p_id.isupper():
                canon_casts.append('')
            else:
                canon_casts.append('(cpg_float *) ')

    f.write('// Struct containing canonical parameters\n')

    struct_values = []
    struct_values_conditioning = []
    for i, p_id in enumerate(p_ids):
        p = parameter_canon.p[p_id]
        if type(p) == dict:
            length = len(p['x'])
        else:
            length = len(p)
        if length == 0:
            struct_values.append('0')
            if solver_interface.inmemory_preconditioning:
                struct_values_conditioning.append('0')
        elif p_id=='d':
            struct_values.append('%.20f' % p)
            if solver_interface.inmemory_preconditioning:
                struct_values_conditioning.append('%.20f' % p)
        else:
            struct_values.append('&%scanon_%s' % (configuration.prefix, p_id))
            if solver_interface.inmemory_preconditioning:
                struct_values_conditioning.append('&%scanon_%s_conditioning' % (configuration.prefix, p_id))

    write_struct_def(f, p_ids, canon_casts, struct_values, '%sCanon_Params' % configuration.prefix, 'Canon_Params_t')
    f.write('\n')
    if solver_interface.inmemory_preconditioning:
        write_struct_def(f, p_ids, canon_casts, struct_values_conditioning, '%sCanon_Params_conditioning' % configuration.prefix,
                         'Canon_Params_t')
        f.write('\n')

    # Boolean struct for outdated parameter flags
    f.write('// Struct containing flags for outdated canonical parameters\n')
    f.write('Canon_Outdated_t %sCanon_Outdated = {\n' % configuration.prefix)
    for p_id in parameter_canon.p.keys():
        f.write('.%s = 0,\n' % p_id)
    f.write('};\n\n')

    prim_cast = []
    if any(variable_info.name_to_sym) or not solver_interface.sol_statically_allocated:
        f.write('// User-defined variables\n')
    for name, value in variable_info.name_to_init.items():
        if is_mathematical_scalar(value):
            prim_cast.append('')
        else:
            prim_cast.append('(cpg_float *) ')
            if variable_info.name_to_sym[name] or not solver_interface.sol_statically_allocated:
                write_vec_def(f, value.flatten(order='F'), configuration.prefix + name, 'cpg_float')
                f.write('\n')

    f.write('// Struct containing primal solution\n')
    CPG_Prim_fields = list(variable_info.name_to_init.keys())
    CPG_Prim_values = []
    for name, var in variable_info.name_to_init.items():
        offset = variable_info.name_to_offset[name]
        if is_mathematical_scalar(var):
            CPG_Prim_values.append('0')
        else:
            if variable_info.name_to_sym[name] or not solver_interface.sol_statically_allocated:
                CPG_Prim_values.append('&' + configuration.prefix + name)
            else:
                if configuration.solver_name == 'OSQP':
                    CPG_Prim_values.append('&xsolution + %d' % offset)
                elif configuration.solver_name == 'SCS':
                    CPG_Prim_values.append('&%sscs_x + %d' % (configuration.prefix, offset))
    write_struct_def(f, CPG_Prim_fields, prim_cast, CPG_Prim_values, '%sCPG_Prim' % configuration.prefix, 'CPG_Prim_t')

    if len(dual_variable_info.name_to_init) > 0:
        dual_cast = []
        if not solver_interface.sol_statically_allocated:
            f.write('\n// Dual variables associated with user-defined constraints\n')
        for name, value in dual_variable_info.name_to_init.items():
            if is_mathematical_scalar(value):
                dual_cast.append('')
            else:
                dual_cast.append('(cpg_float *) ')
                if not solver_interface.sol_statically_allocated:
                    write_vec_def(f, value.flatten(order='F'), configuration.prefix + name, 'cpg_float')
                    f.write('\n')

        f.write('// Struct containing dual solution\n')
        CPG_Dual_fields = dual_variable_info.name_to_init.keys()
        CPG_Dual_values = []
        for name, var in dual_variable_info.name_to_init.items():
            vec = dual_variable_info.name_to_vec[name]
            offset = dual_variable_info.name_to_offset[name]
            if is_mathematical_scalar(var):
                CPG_Dual_values.append('0')
            else:
                if configuration.solver_name == 'OSQP':
                    CPG_Dual_values.append('&%ssolution + %d' % (vec, offset))
                elif configuration.solver_name == 'SCS':
                    CPG_Dual_values.append('&%sscs_%s + %d' % (configuration.prefix, vec, offset))
                else:
                    CPG_Dual_values.append('&' + configuration.prefix + name)
        write_struct_def(f, CPG_Dual_fields, dual_cast, CPG_Dual_values, '%sCPG_Dual' % configuration.prefix,
                         'CPG_Dual_t')

    f.write('\n// Struct containing solver info\n')
    CPG_Info_fields = ['obj_val', 'iter', 'status', 'pri_res', 'dua_res']
    CPG_Info_values = ['0', '0', ('0' if solver_interface.status_is_int else '"unknown"'), '0', '0']
    info_cast = ['', '', '', '', '']
    write_struct_def(f, CPG_Info_fields, info_cast, CPG_Info_values, '%sCPG_Info' % configuration.prefix, 'CPG_Info_t')

    f.write('\n// Struct containing solution and info\n')
    if len(dual_variable_info.name_to_init) > 0:
        CPG_Result_fields = ['prim', 'dual', 'info']
        result_cast = ['', '', '']
        CPG_Result_values = ['&%sCPG_Prim' % configuration.prefix, '&%sCPG_Dual' % configuration.prefix,
                             '&%sCPG_Info' % configuration.prefix]
    else:
        CPG_Result_fields = ['prim', 'info']
        result_cast = ['', '']
        CPG_Result_values = ['&%sCPG_Prim' % configuration.prefix, '&%sCPG_Info' % configuration.prefix]
    write_struct_def(f, CPG_Result_fields, result_cast, CPG_Result_values, '%sCPG_Result' % configuration.prefix,
                     'CPG_Result_t')

    if configuration.solver_name == 'SCS':

        f.write('\n// SCS matrix A\n')
        scs_A_fiels = ['x', 'i', 'p', 'm', 'n']
        scs_A_casts = ['(cpg_float *) ', '(cpg_int *) ', '(cpg_int *) ', '', '']
        scs_A_values = ['&%scanon_A_x' % configuration.prefix, '&%scanon_A_i' % configuration.prefix,
                        '&%scanon_A_p' % configuration.prefix, str(solver_interface.canon_constants['m']),
                        str(solver_interface.canon_constants['n'])]
        write_struct_def(f, scs_A_fiels, scs_A_casts, scs_A_values, '%sScs_A' % configuration.prefix, 'ScsMatrix')

        f.write('\n// Struct containing SCS data\n')
        scs_d_fiels = ['m', 'n', 'A', 'P', 'b', 'c']
        scs_d_casts = ['', '', '', '', '(cpg_float *) ', '(cpg_float *) ']
        scs_d_values = [str(solver_interface.canon_constants['m']), str(solver_interface.canon_constants['n']), '&%sScs_A'
                        % configuration.prefix, 'SCS_NULL', '&%scanon_b' % configuration.prefix, '&%scanon_c'
                        % configuration.prefix]
        write_struct_def(f, scs_d_fiels, scs_d_casts, scs_d_values, '%sScs_D' % configuration.prefix, 'ScsData')

        if solver_interface.canon_constants['qsize'] > 0:
            f.write('\n// SCS array of SOC dimensions\n')
            write_vec_def(f, solver_interface.canon_constants['q'], '%sscs_q' % configuration.prefix, 'cpg_int')
            k_field_q_str = '&%sscs_q' % configuration.prefix
        else:
            k_field_q_str = 'SCS_NULL'

        f.write('\n// Struct containing SCS cone data\n')
        scs_k_fields = ['z', 'l', 'bu', 'bl', 'bsize', 'q', 'qsize', 's', 'ssize', 'ep', 'ed', 'p', 'psize']
        scs_k_casts = ['', '', '(cpg_float *) ', '(cpg_float *) ', '', '(cpg_int *) ', '', '(cpg_int *) ', '', '', '',
                       '(cpg_float *) ', '']
        scs_k_values = [str(solver_interface.canon_constants['z']), str(solver_interface.canon_constants['l']), 'SCS_NULL', 'SCS_NULL', '0',
                        k_field_q_str, str(solver_interface.canon_constants['qsize']), 'SCS_NULL', '0', '0', '0', 'SCS_NULL', '0']
        write_struct_def(f, scs_k_fields, scs_k_casts, scs_k_values, '%sScs_K' % configuration.prefix, 'ScsCone')

        f.write('\n// Struct containing SCS settings\n')
        scs_stgs_fields = list(solver_interface.stgs_names_to_default.keys())
        scs_stgs_casts = ['']*len(scs_stgs_fields)
        scs_stgs_values = list(solver_interface.stgs_names_to_default.values())
        write_struct_def(f, scs_stgs_fields, scs_stgs_casts, scs_stgs_values, configuration.prefix + 'Canon_Settings', 'ScsSettings')

        f.write('\n// SCS solution\n')
        write_vec_def(f, np.zeros(solver_interface.canon_constants['n']), '%sscs_x' % configuration.prefix, 'cpg_float')
        write_vec_def(f, np.zeros(solver_interface.canon_constants['m']), '%sscs_y' % configuration.prefix, 'cpg_float')
        write_vec_def(f, np.zeros(solver_interface.canon_constants['m']), '%sscs_s' % configuration.prefix, 'cpg_float')

        f.write('\n// Struct containing SCS solution\n')
        scs_sol_fields = ['x', 'y', 's']
        scs_sol_casts = ['(cpg_float *) ', '(cpg_float *) ', '(cpg_float *) ']
        scs_sol_values = ['&%sscs_x' % configuration.prefix, '&%sscs_y' % configuration.prefix, '&%sscs_s'
                          % configuration.prefix]
        write_struct_def(f, scs_sol_fields, scs_sol_casts, scs_sol_values, '%sScs_Sol'
                         % configuration.prefix, 'ScsSolution')

        f.write('\n// Struct containing SCS information\n')
        scs_info_fields = ['iter', 'status', 'status_val', 'scale_updates', 'pobj', 'dobj', 'res_pri', 'res_dual',
                           'gap', 'res_infeas', 'res_unbdd_a', 'res_unbdd_p', 'comp_slack', 'setup_time', 'solve_time',
                           'scale', 'rejected_accel_steps', 'accepted_accel_steps', 'lin_sys_time', 'cone_time',
                           'accel_time']
        scs_info_casts = ['']*len(scs_info_fields)
        scs_info_values = ['0', '"unknown"', '0', '0', '0', '0', '99', '99', '99', '99', '99', '99', '99', '0', '0',
                           '1', '0', '0', '0', '0', '0']
        write_struct_def(f, scs_info_fields, scs_info_casts, scs_info_values, '%sScs_Info'
                         % configuration.prefix, 'ScsInfo')

        f.write('\n// Pointer to struct containing SCS workspace\n')
        f.write('ScsWork* %sScs_Work = 0;\n' % configuration.prefix)

    if configuration.solver_name == 'ECOS':

        f.write('\n// Struct containing solver settings\n')
        f.write('Canon_Settings_t %sCanon_Settings = {\n' % configuration.prefix)
        for name, default in solver_interface.stgs_names_to_default.items():
            f.write('.%s = %s,\n' % (name, default))
        f.write('};\n')
        if solver_interface.canon_constants['n_cones'] > 0:
            f.write('\n// ECOS array of SOC dimensions\n')
            write_vec_def(f, solver_interface.canon_constants['q'], '%secos_q' % configuration.prefix, 'cpg_int')
        f.write('\n// ECOS workspace\n')
        f.write('pwork* %secos_workspace = 0;\n' % configuration.prefix)
        f.write('\n// ECOS exit flag\n')
        f.write('cpg_int %secos_flag = -99;\n' % configuration.prefix)


def write_workspace_prot(f, configuration, variable_info, dual_variable_info, parameter_info, parameter_canon, solver_interface):
    """"
    Write workspace initialization to file
    """

    write_description(f, 'c', 'Type definitions and variable declarations')
    for header_file in solver_interface.header_files:
        f.write('#include "%s"\n' % header_file)

    # definition safeguard
    f.write('\n#ifndef CPG_TYPES_H\n')
    f.write('# define CPG_TYPES_H\n\n')

    f.write('typedef %s cpg_float;\n' % solver_interface.numeric_types['float'])
    f.write('typedef %s cpg_int;\n\n' % solver_interface.numeric_types['int'])

    # struct definitions
    f.write('// Compressed sparse column matrix\n')
    f.write('typedef struct {\n')
    f.write('  cpg_int      nzmax;\n')
    f.write('  cpg_int      n;\n')
    f.write('  cpg_int      m;\n')
    f.write('  cpg_int      *p;\n')
    f.write('  cpg_int      *i;\n')
    f.write('  cpg_float    *x;\n')
    f.write('  cpg_int      nz;\n')
    f.write('} cpg_csc;\n\n')

    if configuration.unroll:
        f.write('// User-defined parameters\n')
        f.write('typedef struct {\n')
        # single user parameters
        for name, size in parameter_info.name_to_size_usp.items():
            if size == 1:
                s = ''
            else:
                s = '*'
            f.write('  cpg_float    %s   // Your parameter %s\n' % ((s+name+';').ljust(9), name))
        f.write('} CPG_Params_t;\n\n')

    f.write('// Canonical parameters\n')
    f.write('typedef struct {\n')
    for p_id in parameter_canon.p.keys():
        if p_id.isupper():
            f.write('  cpg_csc        *%s   // Canonical parameter %s\n' % ((p_id+';').ljust(8), p_id))
        else:
            if p_id == 'd':
                s = ''
            else:
                s = '*'
            f.write('  cpg_float    %s   // Canonical parameter %s\n' % ((s+p_id+';').ljust(9), p_id))
    f.write('} Canon_Params_t;\n\n')

    f.write('// Flags indicating outdated canonical parameters\n')
    f.write('typedef struct {\n')
    for p_id in parameter_canon.p.keys():
        f.write('  int        %s    // Bool, if canonical parameter %s outdated\n' % ((p_id + ';').ljust(8), p_id))
    f.write('} Canon_Outdated_t;\n\n')

    f.write('// Primal solution\n')
    f.write('typedef struct {\n')
    for name, var in variable_info.name_to_init.items():
        if is_mathematical_scalar(var):
            s = ''
        else:
            s = '*'
        f.write('  cpg_float    %s   // Your variable %s\n' % ((s + name + ';').ljust(9), name))
    f.write('} CPG_Prim_t;\n\n')

    if len(dual_variable_info.name_to_init) > 0:
        f.write('// Dual solution\n')
        f.write('typedef struct {\n')
        for name, var in dual_variable_info.name_to_init.items():
            if is_mathematical_scalar(var):
                s = ''
            else:
                s = '*'
            f.write('  cpg_float    %s   // Your dual variable for constraint %s\n' % ((s + name + ';').ljust(9), name))
        f.write('} CPG_Dual_t;\n\n')

    f.write('// Solver information\n')
    f.write('typedef struct {\n')
    f.write('  cpg_float    obj_val;    // Objective function value\n')
    f.write('  cpg_int      iter;       // Number of iterations\n')
    f.write('  %sstatus;     // Solver status\n' %
                ('cpg_int      ' if solver_interface.status_is_int else 'char       *'))
    f.write('  cpg_float    pri_res;    // Primal residual\n')
    f.write('  cpg_float    dua_res;    // Dual residual\n')
    f.write('} CPG_Info_t;\n\n')

    f.write('// Solution and solver information\n')
    f.write('typedef struct {\n')
    f.write('  CPG_Prim_t *prim;      // Primal solution\n')
    if len(dual_variable_info.name_to_init) > 0:
        f.write('  CPG_Dual_t *dual;      // Dual solution\n')
    f.write('  CPG_Info_t *info;      // Solver info\n')
    f.write('} CPG_Result_t;\n\n')

    if configuration.solver_name == 'ECOS':
        f.write('// Solver settings\n')
        f.write('typedef struct {\n')
        for name, typ in solver_interface.stgs_names_to_type.items():
            f.write('  %s%s;\n' % (typ.ljust(11), name))
        f.write('} Canon_Settings_t;\n\n')

    f.write('#endif // ifndef CPG_TYPES_H\n')

    if configuration.unroll:
        f.write('\n// User-defined parameters\n')
        for name, value in parameter_info.writable.items():
            if not is_mathematical_scalar(value):
                write_vec_prot(f, value, configuration.prefix+'cpg_'+name, 'cpg_float')
        f.write('\n// Struct containing all user-defined parameters\n')
        write_struct_prot(f, '%sCPG_Params' % configuration.prefix, 'CPG_Params_t')
    else:
        f.write('\n// Vector containing flattened user-defined parameters\n')
        write_vec_prot(f, parameter_info.flat_usp, '%scpg_params_vec' % configuration.prefix, 'cpg_float')
        f.write('\n// Sparse mappings from user-defined to canonical parameters\n')
        for p_id, mapping in parameter_canon.p_id_to_mapping.items():
            if parameter_canon.p_id_to_changes[p_id]:
                write_mat_prot(f, csc_to_dict(mapping), '%scanon_%s_map' % (configuration.prefix, p_id))

    f.write('\n// Canonical parameters\n')
    for p_id, p in parameter_canon.p.items():
        if p_id != 'd':
            write_param_prot(f, p, p_id, configuration.prefix, '')
            if solver_interface.inmemory_preconditioning:
                write_param_prot(f, p, p_id, configuration.prefix, '_conditioning')

    f.write('\n// Struct containing canonical parameters\n')
    write_struct_prot(f, '%sCanon_Params' % configuration.prefix, 'Canon_Params_t')
    if solver_interface.inmemory_preconditioning:
        write_struct_prot(f, '%sCanon_Params_conditioning' % configuration.prefix, 'Canon_Params_t')

    f.write('\n// Struct containing flags for outdated canonical parameters\n')
    f.write('extern Canon_Outdated_t %sCanon_Outdated;\n' % configuration.prefix)

    if any(variable_info.name_to_sym.values()) or not solver_interface.sol_statically_allocated:
        f.write('\n// User-defined variables\n')
        for name, value in variable_info.name_to_init.items():
            if variable_info.name_to_sym[name] or not solver_interface.sol_statically_allocated:
                if not is_mathematical_scalar(value):
                    write_vec_prot(f, value.flatten(order='F'), configuration.prefix+'cpg_'+name,
                                                'cpg_float')

    if not solver_interface.sol_statically_allocated:
        f.write('\n// Dual variables associated with user-defined constraints\n')
        for name, value in dual_variable_info.name_to_init.items():
            if not is_mathematical_scalar(value):
                write_vec_prot(f, value.flatten(order='F'), configuration.prefix+'cpg_'+name, 'cpg_float')

    f.write('\n// Struct containing primal solution\n')
    write_struct_prot(f, '%sCPG_Prim' % configuration.prefix, 'CPG_Prim_t')

    if len(dual_variable_info.name_to_init) > 0:
        f.write('\n// Struct containing dual solution\n')
        write_struct_prot(f, '%sCPG_Dual' % configuration.prefix, 'CPG_Dual_t')

    f.write('\n// Struct containing solver info\n')
    write_struct_prot(f, '%sCPG_Info' % configuration.prefix, 'CPG_Info_t')

    f.write('\n// Struct containing solution and info\n')
    write_struct_prot(f, '%sCPG_Result' % configuration.prefix, 'CPG_Result_t')

    if configuration.solver_name == 'SCS':
        f.write('\n// SCS matrix A\n')
        write_struct_prot(f, '%sscs_A' % configuration.prefix, 'ScsMatrix')
        f.write('\n// Struct containing SCS data\n')
        write_struct_prot(f, '%sScs_D' % configuration.prefix, 'ScsData')
        if solver_interface.canon_constants['qsize'] > 0:
            f.write('\n// SCS array of SOC dimensions\n')
            write_vec_prot(f, solver_interface.canon_constants['q'], '%sscs_q' % configuration.prefix, 'cpg_int')
        f.write('\n// Struct containing SCS cone data\n')
        write_struct_prot(f, '%sScs_K' % configuration.prefix, 'ScsCone')
        f.write('\n// Struct containing SCS settings\n')
        write_struct_prot(f, configuration.prefix + 'Canon_Settings', 'ScsSettings')
        f.write('\n// SCS solution\n')
        write_vec_prot(f, np.zeros(solver_interface.canon_constants['n']), '%sscs_x' % configuration.prefix,
                                    'cpg_float')
        write_vec_prot(f, np.zeros(solver_interface.canon_constants['m']), '%sscs_y' % configuration.prefix,
                                    'cpg_float')
        write_vec_prot(f, np.zeros(solver_interface.canon_constants['m']), '%sscs_s' % configuration.prefix,
                                    'cpg_float')
        f.write('\n// Struct containing SCS solution\n')
        write_struct_prot(f, '%sScs_Sol' % configuration.prefix, 'ScsSolution')
        f.write('\n// Struct containing SCS information\n')
        write_struct_prot(f, '%sScs_Info' % configuration.prefix, 'ScsInfo')
        f.write('\n// Pointer to struct containing SCS workspace\n')
        write_struct_prot(f, '%sScs_Work' % configuration.prefix, 'ScsWork*')

    if configuration.solver_name == 'ECOS':
        f.write('\n// Struct containing solver settings\n')
        write_struct_prot(f, configuration.prefix + 'Canon_Settings', 'Canon_Settings_t')
        if solver_interface.canon_constants['n_cones'] > 0:
            f.write('\n// ECOS array of SOC dimensions\n')
            write_vec_prot(f, solver_interface.canon_constants['q'], '%secos_q' % configuration.prefix, 'cpg_int')
        f.write('\n// ECOS workspace\n')
        f.write('extern pwork* %secos_workspace;\n' % configuration.prefix)
        f.write('\n// ECOS exit flag\n')
        f.write('extern cpg_int %secos_flag;\n' % configuration.prefix)


def write_solve_def(f, configuration, variable_info, dual_variable_info, parameter_info, parameter_canon, solver_interface):
    """
    Write parameter initialization function to file
    """

    write_description(f, 'c', 'Function definitions')
    f.write('#include "cpg_solve.h"\n')
    f.write('#include "cpg_workspace.h"\n\n')

    if not configuration.unroll:
        f.write('static cpg_int i;\n')
        f.write('static cpg_int j;\n')

    if configuration.unroll and solver_interface.inmemory_preconditioning:
        f.write('static cpg_int i;\n')

    f.write('\n// Update user-defined parameters\n')
    if configuration.unroll:
        for user_p_name, Canon_outdated_names in parameter_canon.user_p_name_to_canon_outdated.items():
            if parameter_info.name_to_size_usp[user_p_name] == 1:
                f.write('void %scpg_update_%s(cpg_float val){\n' % (configuration.prefix, user_p_name))
                f.write('  %sCPG_Params.%s = val;\n' % (configuration.prefix, user_p_name))
            else:
                f.write('void %scpg_update_%s(cpg_int idx, cpg_float val){\n' % (configuration.prefix, user_p_name))
                f.write('  %sCPG_Params.%s[idx] = val;\n' % (configuration.prefix, user_p_name))
            for Canon_outdated_name in Canon_outdated_names:
                f.write('  %sCanon_Outdated.%s = 1;\n' % (configuration.prefix, Canon_outdated_name))
            f.write('}\n\n')
    else:
        for base_col, name in parameter_info.col_to_name_usp.items():
            Canon_outdated_names = parameter_canon.user_p_name_to_canon_outdated[name]
            if parameter_info.name_to_size_usp[name] == 1:
                f.write('void %scpg_update_%s(cpg_float val){\n' % (configuration.prefix, name))
                f.write('  %scpg_params_vec[%d] = val;\n' % (configuration.prefix, base_col))
            else:
                f.write('void %scpg_update_%s(cpg_int idx, cpg_float val){\n' % (configuration.prefix, name))
                f.write('  %scpg_params_vec[idx+%d] = val;\n' % (configuration.prefix, base_col))
            for Canon_outdated_name in Canon_outdated_names:
                f.write('  %sCanon_Outdated.%s = 1;\n' % (configuration.prefix, Canon_outdated_name))
            f.write('}\n\n')

    f.write('// Map user-defined to canonical parameters\n')

    for p_id, mapping in parameter_canon.p_id_to_mapping.items():
        if parameter_canon.p_id_to_changes[p_id]:
            f.write('void %scpg_canonicalize_%s(){\n' % (configuration.prefix, p_id))
            if p_id.isupper():
                s = '->x'
            else:
                s = ''
            if configuration.unroll:
                write_canonicalize_explicit(f, p_id, s, mapping, parameter_info.col_to_name_usp,
                                            parameter_info.name_to_size_usp, configuration.prefix)
            else:
                write_canonicalize(f, p_id, s, mapping, configuration.prefix)
            f.write('}\n\n')

    if configuration.solver_name == 'OSQP':
        obj_str = 'workspace.info->obj_val'
        prim_str = 'workspace.solution->x'
        dual_str = 'workspace.solution->'
    elif configuration.solver_name == 'SCS':
        obj_str = '%sScs_Info.pobj' % configuration.prefix
        prim_str = '%sscs_x' % configuration.prefix
        dual_str = '%sscs_' % configuration.prefix
    elif configuration.solver_name == 'ECOS':
        obj_str = '%secos_workspace->info->pcost' % configuration.prefix
        prim_str = '%secos_workspace->x' % configuration.prefix
        dual_str = '%secos_workspace->' % configuration.prefix
    else:
        raise ValueError("Only OSQP and ECOS are supported!")

    if solver_interface.ret_prim_func_exists(variable_info):
        f.write('// Retrieve primal solution in terms of user-defined variables\n')
        f.write('void %scpg_retrieve_prim(){\n' % configuration.prefix)
        for var_name, indices in variable_info.name_to_indices.items():
            if len(indices) == 1:
                f.write('  %sCPG_Prim.%s = %s[%d];\n' % (configuration.prefix, var_name, prim_str, indices))
            elif variable_info.name_to_sym[var_name] or not solver_interface.sol_statically_allocated:
                for i, idx in enumerate(indices):
                    f.write('  %sCPG_Prim.%s[%d] = %s[%d];\n' % (configuration.prefix, var_name, i, prim_str, idx))
        f.write('}\n\n')

    if solver_interface.ret_dual_func_exists(dual_variable_info):
        f.write('// Retrieve dual solution in terms of user-defined constraints\n')
        f.write('void %scpg_retrieve_dual(){\n' % configuration.prefix)
        for var_name, (vector, indices) in dual_variable_info.name_to_indices.items():
            if len(indices) == 1:
                f.write('  %sCPG_Dual.%s = %s%s[%d];\n' % (configuration.prefix, var_name, dual_str, vector, indices))
            elif not solver_interface.sol_statically_allocated:
                for i, idx in enumerate(indices):
                    f.write('  %sCPG_Dual.%s[%d] = %s%s[%d];\n'
                            % (configuration.prefix, var_name, i, dual_str, vector, idx))
        f.write('}\n\n')

    f.write('// Retrieve solver info\n')
    f.write('void %scpg_retrieve_info(){\n' % configuration.prefix)
    if parameter_canon.nonzero_d:
        d_str = ' + %sCanon_Params.d' % configuration.prefix
    else:
        d_str = ''
    if parameter_canon.is_maximization:
        f.write('  %sCPG_Info.obj_val = -(%s%s);\n' % (configuration.prefix, obj_str, d_str))
    else:
        f.write('  %sCPG_Info.obj_val = %s%s;\n' % (configuration.prefix, obj_str, d_str))
    if configuration.solver_name == 'OSQP':
        f.write('  %sCPG_Info.iter = workspace.info->iter;\n' % configuration.prefix)
        f.write('  %sCPG_Info.status = workspace.info->status;\n' % configuration.prefix)
        f.write('  %sCPG_Info.pri_res = workspace.info->pri_res;\n' % configuration.prefix)
        f.write('  %sCPG_Info.dua_res = workspace.info->dua_res;\n' % configuration.prefix)
    elif configuration.solver_name == 'SCS':
        f.write('  %sCPG_Info.iter = %sScs_Info.iter;\n' % (configuration.prefix, configuration.prefix))
        f.write('  %sCPG_Info.status = %sScs_Info.status;\n' % (configuration.prefix, configuration.prefix))
        f.write('  %sCPG_Info.pri_res = %sScs_Info.res_pri;\n' % (configuration.prefix, configuration.prefix))
        f.write('  %sCPG_Info.dua_res = %sScs_Info.res_dual;\n' % (configuration.prefix, configuration.prefix))
    elif configuration.solver_name == 'ECOS':
        f.write('  %sCPG_Info.iter = %secos_workspace->info->iter;\n' % (configuration.prefix, configuration.prefix))
        f.write('  %sCPG_Info.status = %secos_flag;\n' % (configuration.prefix, configuration.prefix))
        f.write('  %sCPG_Info.pri_res = %secos_workspace->info->pres;\n'
                % (configuration.prefix, configuration.prefix))
        f.write('  %sCPG_Info.dua_res = %secos_workspace->info->dres;\n'
                % (configuration.prefix, configuration.prefix))
    f.write('}\n\n')

    f.write('// Solve via canonicalization, canonical solve, retrieval\n')
    f.write('void %scpg_solve(){\n' % configuration.prefix)
    f.write('  // Canonicalize if necessary\n')
    if configuration.solver_name == 'OSQP':

        if parameter_canon.p_id_to_changes['P'] and parameter_canon.p_id_to_changes['A']:
            f.write('  if (%sCanon_Outdated.P && %sCanon_Outdated.A) {\n'
                    % (configuration.prefix, configuration.prefix))
            f.write('    %scpg_canonicalize_P();\n' % configuration.prefix)
            f.write('    %scpg_canonicalize_A();\n' % configuration.prefix)
            f.write('    osqp_update_P_A(&workspace, %sCanon_Params.P->x, 0, 0, %sCanon_Params.A->x, 0, 0);\n'
                    % (configuration.prefix, configuration.prefix))
            f.write('  } else if (%sCanon_Outdated.P) {\n' % configuration.prefix)
            f.write('    %scpg_canonicalize_P();\n' % configuration.prefix)
            f.write('    osqp_update_P(&workspace, %sCanon_Params.P->x, 0, 0);\n' % configuration.prefix)
            f.write('  } else if (%sCanon_Outdated.A) {\n' % configuration.prefix)
            f.write('    %scpg_canonicalize_A();\n' % configuration.prefix)
            f.write('    osqp_update_A(&workspace, %sCanon_Params.A->x, 0, 0);\n' % configuration.prefix)
            f.write('  }\n')
        else:
            if parameter_canon.p_id_to_changes['P']:
                f.write('  if (%sCanon_Outdated.P) {\n' % configuration.prefix)
                f.write('    %scpg_canonicalize_P();\n' % configuration.prefix)
                f.write('    osqp_update_P(&workspace, %sCanon_Params.P->x, 0, 0);\n' % configuration.prefix)
                f.write('  }\n')
            if parameter_canon.p_id_to_changes['A']:
                f.write('  if (%sCanon_Outdated.A) {\n' % configuration.prefix)
                f.write('    %scpg_canonicalize_A();\n' % configuration.prefix)
                f.write('    osqp_update_A(&workspace, %sCanon_Params.A->x, 0, 0);\n' % configuration.prefix)
                f.write('  }\n')

        if parameter_canon.p_id_to_changes['q']:
            f.write('  if (%sCanon_Outdated.q) {\n' % configuration.prefix)
            f.write('    %scpg_canonicalize_q();\n' % configuration.prefix)
            f.write('    osqp_update_lin_cost(&workspace, %sCanon_Params.q);\n' % configuration.prefix)
            f.write('  }\n')

        if parameter_canon.p_id_to_changes['d']:
            f.write('  if (%sCanon_Outdated.d) {\n' % configuration.prefix)
            f.write('    %scpg_canonicalize_d();\n' % configuration.prefix)
            f.write('  }\n')

        if parameter_canon.p_id_to_changes['l'] and parameter_canon.p_id_to_changes['u']:
            f.write('  if (%sCanon_Outdated.l && %sCanon_Outdated.u) {\n'
                    % (configuration.prefix, configuration.prefix))
            f.write('    %scpg_canonicalize_l();\n' % configuration.prefix)
            f.write('    %scpg_canonicalize_u();\n' % configuration.prefix)
            f.write('    osqp_update_bounds(&workspace, %sCanon_Params.l, %sCanon_Params.u);\n'
                    % (configuration.prefix, configuration.prefix))
            f.write('  } else if (%sCanon_Outdated.l) {\n' % configuration.prefix)
            f.write('    %scpg_canonicalize_l();\n' % configuration.prefix)
            f.write('    osqp_update_lower_bound(&workspace, %sCanon_Params.l);\n' % configuration.prefix)
            f.write('  } else if (%sCanon_Outdated.u) {\n' % configuration.prefix)
            f.write('    %scpg_canonicalize_u();\n' % configuration.prefix)
            f.write('    osqp_update_upper_bound(&workspace, %sCanon_Params.u);\n' % configuration.prefix)
            f.write('  }\n')
        else:
            if parameter_canon.p_id_to_changes['l']:
                f.write('  if (%sCanon_Outdated.l) {\n' % configuration.prefix)
                f.write('    %scpg_canonicalize_l();\n' % configuration.prefix)
                f.write('    osqp_update_lower_bound(&workspace, %sCanon_Params.l);\n' % configuration.prefix)
                f.write('  }\n')
            if parameter_canon.p_id_to_changes['u']:
                f.write('  if (%sCanon_Outdated.u) {\n' % configuration.prefix)
                f.write('    %scpg_canonicalize_u();\n' % configuration.prefix)
                f.write('    osqp_update_upper_bound(&workspace, %sCanon_Params.u);\n' % configuration.prefix)
                f.write('  }\n')

    elif configuration.solver_name in ['SCS', 'ECOS']:

        for p_id, changes in parameter_canon.p_id_to_changes.items():
            if changes:
                f.write('  if (%sCanon_Outdated.%s) {\n' % (configuration.prefix, p_id))
                f.write('    %scpg_canonicalize_%s();\n' % (configuration.prefix, p_id))
                f.write('  }\n')

    if solver_interface.inmemory_preconditioning:
        for p_id, size in parameter_canon.p_id_to_size.items():
                if size == 1:
                    f.write('  %sCanon_Params_conditioning.%s = %sCanon_Params.%s;\n'
                            % (configuration.prefix, p_id, configuration.prefix, p_id))
                elif size > 1:
                    f.write('  for (i=0; i<%d; i++){\n' % size)
                    if p_id.isupper():
                        f.write('    %sCanon_Params_conditioning.%s->x[i] = %sCanon_Params.%s->x[i];\n'
                                % (configuration.prefix, p_id, configuration.prefix, p_id))
                    else:
                        f.write('    %sCanon_Params_conditioning.%s[i] = %sCanon_Params.%s[i];\n'
                                % (configuration.prefix, p_id, configuration.prefix, p_id))
                    f.write('  }\n')

    if configuration.solver_name == 'OSQP':
        f.write('  // Solve with OSQP\n')
        f.write('  osqp_solve(&workspace);\n')
    elif configuration.solver_name == 'SCS':
        f.write('  // Solve with SCS\n')
        f.write('  if (!%sScs_Work || %sCanon_Outdated.A) {\n' % (configuration.prefix, configuration.prefix))
        f.write('    %sScs_Work = scs_init(&%sScs_D, &%sScs_K, &%sCanon_Settings);\n' %
                (configuration.prefix, configuration.prefix, configuration.prefix, configuration.prefix))
        f.write('  } else if (%sCanon_Outdated.b && %sCanon_Outdated.c) {\n' % (configuration.prefix, configuration.prefix))
        f.write('    scs_update(%sScs_Work, %sCanon_Params.b, %sCanon_Params.c);\n' %
                (configuration.prefix, configuration.prefix, configuration.prefix))
        f.write('  } else if (%sCanon_Outdated.b) {\n' % configuration.prefix)
        f.write('    scs_update(%sScs_Work, %sCanon_Params.b, SCS_NULL);\n' %
                (configuration.prefix, configuration.prefix))
        f.write('  } else if (%sCanon_Outdated.c) {\n' % configuration.prefix)
        f.write('    scs_update(%sScs_Work, SCS_NULL, %sCanon_Params.c);\n' %
                (configuration.prefix, configuration.prefix))
        f.write('  }\n')
        f.write('  scs_solve(%sScs_Work, &%sScs_Sol, &%sScs_Info, (%sScs_Work && %sCanon_Settings.warm_start));\n' %
                (configuration.prefix, configuration.prefix, configuration.prefix, configuration.prefix, configuration.prefix))
    elif configuration.solver_name == 'ECOS':
        f.write('  // Initialize / update ECOS workspace and settings\n')
        write_ecos_setup_update(f, solver_interface.canon_constants, configuration.prefix)
        for name in solver_interface.stgs_names_to_type.keys():
            f.write('  %secos_workspace->stgs->%s = %sCanon_Settings.%s;\n'
                    % (configuration.prefix, name, configuration.prefix, name))
        f.write('  // Solve with ECOS\n')
        f.write('  %secos_flag = ECOS_solve(%secos_workspace);\n' % (configuration.prefix, configuration.prefix))

    f.write('  // Retrieve results\n')
    if solver_interface.ret_prim_func_exists(variable_info):
        f.write('  %scpg_retrieve_prim();\n' % configuration.prefix)
    if solver_interface.ret_dual_func_exists(dual_variable_info):
        f.write('  %scpg_retrieve_dual();\n' % configuration.prefix)
    f.write('  %scpg_retrieve_info();\n' % configuration.prefix)

    f.write('  // Reset flags for outdated canonical parameters\n')
    for p_id in parameter_canon.p_id_to_size.keys():
        f.write('  %sCanon_Outdated.%s = 0;\n' % (configuration.prefix, p_id))

    f.write('}\n\n')

    f.write('// Update solver settings\n')
    f.write('void %scpg_set_solver_default_settings(){\n' % configuration.prefix)
    if solver_interface.stgs_reset_function is not None:
        f.write('  %s(&%s);\n' % (
            solver_interface.stgs_reset_function['name'],
            solver_interface.stgs_reset_function['ptr_name'] if solver_interface.stgs_reset_function['ptr_name'] is not None else configuration.prefix + 'Canon_Settings'))
    else:
        for name, value in solver_interface.stgs_names_to_default.items():
            f.write('  %sCanon_Settings.%s = %s;\n' % (configuration.prefix, name, value))
    f.write('}\n')
    for name, typ in solver_interface.stgs_names_to_type.items():
        f.write('\nvoid %scpg_set_solver_%s(%s %s_new){\n' % (configuration.prefix, name, typ, name))
        if solver_interface.stgs_set_function is not None:
            f.write('  %s(&%s, %%s_new);\n' % (
                solver_interface.stgs_set_function['name'],
                solver_interface.stgs_set_function['ptr_name']) % (name, name))
        else:
            f.write('  %sCanon_Settings.%s = %s_new;\n' % (configuration.prefix, name, name))
        f.write('}\n')


def write_solve_prot(f, configuration, variable_info, dual_variable_info, parameter_info, parameter_canon, solver_interface):
    """
    Write function declarations to file
    """

    write_description(f, 'c', 'Function declarations')
    f.write('#include "cpg_workspace.h"\n')

    f.write('\n// Update user-defined parameter values\n')
    for name, size in parameter_info.name_to_size_usp.items():
        if size == 1:
            f.write('extern void %scpg_update_%s(cpg_float val);\n' % (configuration.prefix, name))
        else:
            f.write('extern void %scpg_update_%s(cpg_int idx, cpg_float val);\n' % (configuration.prefix, name))

    f.write('\n// Map user-defined to canonical parameters\n')
    for p_id, changes in parameter_canon.p_id_to_changes.items():
        if changes:
            f.write('extern void %scpg_canonicalize_%s();\n' % (configuration.prefix, p_id))

    if solver_interface.ret_prim_func_exists(variable_info):
        f.write('\n// Retrieve primal solution in terms of user-defined variables\n')
        f.write('extern void %scpg_retrieve_prim();\n' % configuration.prefix)

    if solver_interface.ret_dual_func_exists(dual_variable_info):
        f.write('\n// Retrieve dual solution in terms of user-defined constraints\n')
        f.write('extern void %scpg_retrieve_dual();\n' % configuration.prefix)

    f.write('\n// Retrieve solver information\n')
    f.write('extern void %scpg_retrieve_info();\n' % configuration.prefix)

    f.write('\n// Solve via canonicalization, canonical solve, retrieval\n')
    f.write('extern void %scpg_solve();\n' % configuration.prefix)

    f.write('\n// Update solver settings\n')
    f.write('extern void %scpg_set_solver_default_settings();\n' % configuration.prefix)
    for name, typ in solver_interface.stgs_names_to_type.items():
        f.write('extern void %scpg_set_solver_%s(%s %s_new);\n' % (configuration.prefix, name, typ, name))


def write_example_def(f, configuration, variable_info, dual_variable_info, parameter_info):
    """
    Write main function to file
    """

    write_description(f, 'c', 'Example program for updating parameters, solving, and inspecting the result')
    f.write('#include <stdio.h>\n')
    f.write('#include "cpg_workspace.h"\n')
    f.write('#include "cpg_solve.h"\n\n')
    f.write('static int i;\n\n')

    f.write('int main(int argc, char *argv[]){\n\n')

    f.write('  // Update first entry of every user-defined parameter\n')
    for name, value in parameter_info.writable.items():
        if is_mathematical_scalar(value):
            f.write('  %scpg_update_%s(%.20f);\n' % (configuration.prefix, name, value))
        else:
            f.write('  %scpg_update_%s(0, %.20f);\n' % (configuration.prefix, name, value[0]))

    f.write('\n  // Solve the problem instance\n')
    f.write('  %scpg_solve();\n\n' % configuration.prefix)

    f.write('  // Print objective function value\n')
    f.write('  printf("obj = %%f\\n", %sCPG_Result.info->obj_val);\n\n' % configuration.prefix)

    f.write('  // Print primal solution\n')

    for name, var in variable_info.name_to_init.items():
        if is_mathematical_scalar(var):
            f.write('  printf("%s = %%f\\n", %sCPG_Result.prim->%s);\n' % (name, configuration.prefix, name))
        else:
            f.write('  for(i=0; i<%d; i++) {\n' % var.size)
            f.write('    printf("%s[%%%s] = %%f\\n", i, %sCPG_Result.prim->%s[i]);\n'
                    % (name, int_format_str, configuration.prefix, name))
            f.write('  }\n')

    if len(dual_variable_info.name_to_init) > 0:
        f.write('\n  // Print dual solution\n')
    for name, var in dual_variable_info.name_to_init.items():
        if is_mathematical_scalar(var):
            f.write('  printf("%s = %%f\\n", %sCPG_Result.dual->%s);\n' % (name, configuration.prefix, name))
        else:
            f.write('  for(i=0; i<%d; i++) {\n' % var.size)
            f.write('    printf("%s[%%%s] = %%f\\n", i, %sCPG_Result.dual->%s[i]);\n'
                    % (name, int_format_str, configuration.prefix, name))
            f.write('  }\n')

    f.write('\n  return 0;\n\n')
    f.write('}\n')


def replace_cmake_data(cmake_data, configuration):
    """
    Add configuration.prefix to directory/file lists in top-level CMakeLists.txt
    """

    now = datetime.now()
    cmake_data = cmake_data.replace('%DATE', now.strftime("on %B %d, %Y at %H:%M:%S"))
    cmake_data = cmake_data.replace('cpg_include', configuration.prefix+'cpg_include')
    cmake_data = cmake_data.replace('cpg_head', configuration.prefix + 'cpg_head')
    return cmake_data.replace('cpg_src', configuration.prefix + 'cpg_src')


def write_canon_cmake(f, configuration):
    """
    Pass sources to parent scope in {OSQP/ECOS}_code/CMakeLists.txt
    """

    if configuration.solver_name == 'OSQP':
        f.write('\nset(solver_head "${osqp_headers}" PARENT_SCOPE)')
        f.write('\nset(solver_src "${osqp_src}" PARENT_SCOPE)')
    elif configuration.solver_name == 'SCS':
        f.write('\nset(solver_head')
        f.write('\n  ${${PROJECT_NAME}_HDR}')
        f.write('\n  ${DIRSRC}/private.h')
        f.write('\n  ${${PROJECT_NAME}_LDL_EXTERNAL_HDR}')
        f.write('\n  ${${PROJECT_NAME}_AMD_EXTERNAL_HDR})')
        f.write('\nset(solver_src')
        f.write('\n  ${${PROJECT_NAME}_SRC}')
        f.write('\n  ${DIRSRC}/private.c')
        f.write('\n  ${EXTERNAL}/qdldl/qdldl.c')
        f.write('\n  ${${PROJECT_NAME}_AMD_EXTERNAL_SRC})')
        f.write('\n\nset(solver_head "${solver_head}" PARENT_SCOPE)')
        f.write('\nset(solver_src "${solver_src}" PARENT_SCOPE)')
    elif configuration.solver_name == 'ECOS':
        f.write('\nset(solver_head "${ecos_headers}" PARENT_SCOPE)')
        f.write('\nset(solver_src "${ecos_sources}" PARENT_SCOPE)')


def write_module_def(f, configuration, variable_info, dual_variable_info, parameter_info, solver_interface):
    """
    Write c++ file for pbind11 wrapper
    """

    write_description(f, 'cpp', 'Python binding with pybind11')
    f.write('#include <pybind11/pybind11.h>\n')
    f.write('#include <pybind11/stl.h>\n')
    f.write('#include <ctime>\n')
    f.write('#include "cpg_module.hpp"\n\n')
    f.write('extern "C" {\n')
    f.write('    #include "include/cpg_workspace.h"\n')
    f.write('    #include "include/cpg_solve.h"\n')
    f.write('}\n\n')
    f.write('namespace py = pybind11;\n\n')
    if max(
            max(parameter_info.name_to_size_usp.values(), default=0),
            max(variable_info.name_to_size.values(), default=0),
            max(dual_variable_info.name_to_size.values(), default=0)
    ) > 1:
        f.write('static int i;\n\n')

    # cpp function that maps parameters to results
    f.write('%sCPG_Result_cpp_t %ssolve_cpp(struct %sCPG_Updated_cpp_t& CPG_Updated_cpp, '
            'struct %sCPG_Params_cpp_t& CPG_Params_cpp){\n\n'
            % (configuration.prefix, configuration.prefix, configuration.prefix, configuration.prefix))

    f.write('    // Pass changed user-defined parameter values to the solver\n')
    for name, size in parameter_info.name_to_size_usp.items():
        f.write('    if (CPG_Updated_cpp.%s) {\n' % name)
        if size == 1:
            f.write('        %scpg_update_%s(CPG_Params_cpp.%s);\n' % (configuration.prefix, name, name))
        else:
            f.write('        for(i=0; i<%d; i++) {\n' % size)
            f.write('            %scpg_update_%s(i, CPG_Params_cpp.%s[i]);\n' % (configuration.prefix, name, name))
            f.write('        }\n')
        f.write('    }\n')

    # perform ASA procedure
    f.write('\n    // Solve\n')
    f.write('    std::clock_t ASA_start = std::clock();\n')
    f.write('    %scpg_solve();\n' % configuration.prefix)
    f.write('    std::clock_t ASA_end = std::clock();\n\n')

    # arrange and return results
    f.write('    // Arrange and return results\n')

    f.write('    %sCPG_Prim_cpp_t CPG_Prim_cpp {};\n' % configuration.prefix)
    for name, var in variable_info.name_to_init.items():
        if is_mathematical_scalar(var):
            f.write('    CPG_Prim_cpp.%s = %sCPG_Prim.%s;\n' % (name, configuration.prefix, name))
        else:
            f.write('    for(i=0; i<%d; i++) {\n' % var.size)
            f.write('        CPG_Prim_cpp.%s[i] = %sCPG_Prim.%s[i];\n'
                    % (name, configuration.prefix, name))
            f.write('    }\n')

    if len(dual_variable_info.name_to_init) > 0:
        f.write('    %sCPG_Dual_cpp_t CPG_Dual_cpp {};\n' % configuration.prefix)
        for name, var in dual_variable_info.name_to_init.items():
            if is_mathematical_scalar(var):
                f.write('    CPG_Dual_cpp.%s = %sCPG_Dual.%s;\n' % (name, configuration.prefix, name))
            else:
                f.write('    for(i=0; i<%d; i++) {\n' % var.size)
                f.write('        CPG_Dual_cpp.%s[i] = %sCPG_Dual.%s[i];\n' % (name, configuration.prefix, name))
                f.write('    }\n')

    f.write('    %sCPG_Info_cpp_t CPG_Info_cpp {};\n' % configuration.prefix)
    for field in ['obj_val', 'iter', 'status', 'pri_res', 'dua_res']:
        f.write('    CPG_Info_cpp.%s = %sCPG_Info.%s;\n' % (field, configuration.prefix, field))
    f.write('    CPG_Info_cpp.time = 1.0*(ASA_end-ASA_start) / CLOCKS_PER_SEC;\n')

    f.write('    %sCPG_Result_cpp_t CPG_Result_cpp {};\n' % configuration.prefix)
    f.write('    CPG_Result_cpp.prim = CPG_Prim_cpp;\n')
    if len(dual_variable_info.name_to_init) > 0:
        f.write('    CPG_Result_cpp.dual = CPG_Dual_cpp;\n')
    f.write('    CPG_Result_cpp.info = CPG_Info_cpp;\n')

    # return
    f.write('    return CPG_Result_cpp;\n\n')
    f.write('}\n\n')

    # module
    f.write('PYBIND11_MODULE(cpg_module, m) {\n\n')

    f.write('    py::class_<%sCPG_Params_cpp_t>(m, "%scpg_params")\n' % (configuration.prefix, configuration.prefix))
    f.write('            .def(py::init<>())\n')
    for name in parameter_info.name_to_size_usp.keys():
        f.write('            .def_readwrite("%s", &%sCPG_Params_cpp_t::%s)\n' % (name, configuration.prefix, name))
    f.write('            ;\n\n')

    f.write('    py::class_<%sCPG_Updated_cpp_t>(m, "%scpg_updated")\n'
            % (configuration.prefix, configuration.prefix))
    f.write('            .def(py::init<>())\n')
    for name in parameter_info.name_to_size_usp.keys():
        f.write('            .def_readwrite("%s", &%sCPG_Updated_cpp_t::%s)\n' % (name, configuration.prefix, name))
    f.write('            ;\n\n')

    f.write('    py::class_<%sCPG_Prim_cpp_t>(m, "%scpg_prim")\n' % (configuration.prefix, configuration.prefix))
    f.write('            .def(py::init<>())\n')
    for name in variable_info.name_to_init.keys():
        f.write('            .def_readwrite("%s", &%sCPG_Prim_cpp_t::%s)\n' % (name, configuration.prefix, name))
    f.write('            ;\n\n')

    if len(dual_variable_info.name_to_init) > 0:
        f.write('    py::class_<%sCPG_Dual_cpp_t>(m, "%scpg_dual")\n' % (configuration.prefix, configuration.prefix))
        f.write('            .def(py::init<>())\n')
        for name in dual_variable_info.name_to_init.keys():
            f.write('            .def_readwrite("%s", &%sCPG_Dual_cpp_t::%s)\n' % (name, configuration.prefix, name))
        f.write('            ;\n\n')

    f.write('    py::class_<%sCPG_Info_cpp_t>(m, "%scpg_info")\n' % (configuration.prefix, configuration.prefix))
    f.write('            .def(py::init<>())\n')
    f.write('            .def_readwrite("obj_val", &%sCPG_Info_cpp_t::obj_val)\n' % configuration.prefix)
    f.write('            .def_readwrite("iter", &%sCPG_Info_cpp_t::iter)\n' % configuration.prefix)
    f.write('            .def_readwrite("status", &%sCPG_Info_cpp_t::status)\n' % configuration.prefix)
    f.write('            .def_readwrite("pri_res", &%sCPG_Info_cpp_t::pri_res)\n' % configuration.prefix)
    f.write('            .def_readwrite("dua_res", &%sCPG_Info_cpp_t::dua_res)\n' % configuration.prefix)
    f.write('            .def_readwrite("time", &%sCPG_Info_cpp_t::time)\n' % configuration.prefix)
    f.write('            ;\n\n')

    f.write('    py::class_<%sCPG_Result_cpp_t>(m, "%scpg_result")\n' % (configuration.prefix, configuration.prefix))
    f.write('            .def(py::init<>())\n')
    f.write('            .def_readwrite("cpg_prim", &%sCPG_Result_cpp_t::prim)\n' % configuration.prefix)
    if len(dual_variable_info.name_to_init) > 0:
        f.write('            .def_readwrite("cpg_dual", &%sCPG_Result_cpp_t::dual)\n' % configuration.prefix)
    f.write('            .def_readwrite("cpg_info", &%sCPG_Result_cpp_t::info)\n' % configuration.prefix)
    f.write('            ;\n\n')

    f.write('    m.def("solve", &%ssolve_cpp);\n\n' % configuration.prefix)

    f.write('    m.def("set_solver_default_settings", &%scpg_set_solver_default_settings);\n' % configuration.prefix)
    for name in solver_interface.stgs_names_to_type.keys():
        f.write('    m.def("set_solver_%s", &%scpg_set_solver_%s);\n' % (name, configuration.prefix, name))

    f.write('\n}\n')


def write_module_prot(f, configuration, parameter_info, variable_info, dual_variable_info, solver_interface):
    """
    Write c++ file for pbind11 wrapper
    """

    write_description(f, 'cpp', 'Declarations for Python binding with pybind11')

    # cpp struct containing user-defined parameters
    f.write('// User-defined parameters\n')
    f.write('struct %sCPG_Params_cpp_t {\n' % configuration.prefix)
    for name, size in parameter_info.name_to_size_usp.items():
        if size == 1:
            f.write('    double %s;\n' % name)
        else:
            f.write('    std::array<double, %d> %s;\n' % (size, name))
    f.write('};\n\n')

    # cpp struct containing update flags for user-defined parameters
    f.write('// Flags for updated user-defined parameters\n')
    f.write('struct %sCPG_Updated_cpp_t {\n' % configuration.prefix)
    for name in parameter_info.name_to_size_usp.keys():
        f.write('    bool %s;\n' % name)
    f.write('};\n\n')

    # cpp struct containing primal variables
    f.write('// Primal solution\n')
    f.write('struct %sCPG_Prim_cpp_t {\n' % configuration.prefix)
    for name, var in variable_info.name_to_init.items():
        if is_mathematical_scalar(var):
            f.write('    double %s;\n' % name)
        else:
            f.write('    std::array<double, %d> %s;\n' % (var.size, name))
    f.write('};\n\n')

    # cpp struct containing dual variables
    if len(dual_variable_info.name_to_init) > 0:
        f.write('// Dual solution\n')
        f.write('struct %sCPG_Dual_cpp_t {\n' % configuration.prefix)
        for name, var in dual_variable_info.name_to_init.items():
            if is_mathematical_scalar(var):
                f.write('    double %s;\n' % name)
            else:
                f.write('    std::array<double, %d> %s;\n' % (var.size, name))
        f.write('};\n\n')

    # cpp struct containing info on results
    f.write('// Solver information\n')
    f.write('struct %sCPG_Info_cpp_t {\n' % configuration.prefix)
    f.write('    double obj_val;\n')
    f.write('    int iter;\n')
    f.write('    %s status;\n' % ('int' if solver_interface.status_is_int else 'char*'))
    f.write('    double pri_res;\n')
    f.write('    double dua_res;\n')
    f.write('    double time;\n')
    f.write('};\n\n')

    # cpp struct containing objective value and user-defined variables
    f.write('// Solution and solver information\n')
    f.write('struct %sCPG_Result_cpp_t {\n' % configuration.prefix)
    f.write('    %sCPG_Prim_cpp_t prim;\n' % configuration.prefix)
    if len(dual_variable_info.name_to_init) > 0:
        f.write('    %sCPG_Dual_cpp_t dual;\n' % configuration.prefix)
    f.write('    %sCPG_Info_cpp_t info;\n' % configuration.prefix)
    f.write('};\n\n')

    # cpp function that maps parameters to results
    f.write('// Main solve function\n')
    f.write('%sCPG_Result_cpp_t %ssolve_cpp(struct %sCPG_Updated_cpp_t& CPG_Updated_cpp, '
            'struct %sCPG_Params_cpp_t& CPG_Params_cpp);\n'
            % (configuration.prefix, configuration.prefix, configuration.prefix, configuration.prefix))


def replace_setup_data(text):
    """
    Replace placeholder strings in setup.py file
    """

    # description
    now = datetime.now()
    return text.replace('%DATE', now.strftime("on %B %d, %Y at %H:%M:%S"))


def write_method(f, configuration, variable_info, dual_variable_info, parameter_info, solver_interface):
    """
    Write function to be registered as custom CVXPY solve method
    """

    write_description(f, 'py', 'Custom solve method for CVXPY interface')
    f.write('import time\n')
    f.write('import warnings\n')
    f.write('import numpy as np\n')
    f.write('from cvxpy.reductions import Solution\n')
    f.write('from cvxpy.problems.problem import SolverStats\n')
    f.write('from %s import cpg_module\n\n\n' % configuration.code_dir.replace('/', '.').replace('\\', '.'))

    f.write('def cpg_solve(prob, updated_params=None, **kwargs):\n\n')
    f.write('    # set flags for updated parameters\n')
    f.write('    upd = cpg_module.%scpg_updated()\n' % configuration.prefix)
    f.write('    if updated_params is None:\n')
    p_list_string = ''
    for name in parameter_info.name_to_size_usp.keys():
        p_list_string += '"%s", ' % name
    f.write('        updated_params = [%s]\n' % p_list_string[:-2])
    f.write('    for p in updated_params:\n')
    f.write('        try:\n')
    f.write('            setattr(upd, p, True)\n')
    f.write('        except AttributeError:\n')
    f.write('            raise(AttributeError("%s is not a parameter." % p))\n\n')

    f.write('    # set solver settings\n')
    f.write('    cpg_module.set_solver_default_settings()\n')
    f.write('    for key, value in kwargs.items():\n')
    if configuration.solver_name == 'ECOS':
        f.write('        if key == "max_iters":\n')
        f.write('            key = "maxit"\n')
    f.write('        try:\n')
    f.write('            eval(\'cpg_module.set_solver_%s(value)\' % key)\n')
    f.write('        except AttributeError:\n')
    f.write('            raise(AttributeError(\'Solver setting "%s" not available.\' % key))\n\n')

    f.write('    # set parameter values\n')
    f.write('    par = cpg_module.%scpg_params()\n' % configuration.prefix)
    # prob.param_dict is a computed property. Avoid repeated calls in the loop.
    f.write('    param_dict = prob.param_dict\n')
    for name, size in parameter_info.name_to_size_usp.items():
        if name in parameter_info.name_to_sparsity.keys():
            f.write('    n = param_dict[\'%s\'].shape[0]\n' % name)
            if parameter_info.name_to_sparsity_type[name] == 'diag':
                f.write('    %s_coordinates = np.arange(0, n**2, n+1)\n' % name)
            else:
                f.write('    %s_coordinates = np.unique([coord[0]+coord[1]*n for coord in '
                        'param_dict[\'%s\'].attributes[\'sparsity\']])\n' % (name, name))
            if size == 1:
                f.write('    par.%s = param_dict[\'%s\'].value[coordinates]\n' % (name, name))
            else:
                f.write('    %s_value = []\n' % name)
                f.write('    %s_flat = param_dict[\'%s\'].value.flatten(order=\'F\')\n' % (name, name))
                f.write('    for coord in %s_coordinates:\n' % name)
                f.write('        %s_value.append(%s_flat[coord])\n' % (name, name))
                f.write('        %s_flat[coord] = 0\n' % name)
                f.write('    if np.sum(np.abs(%s_flat)) > 0:\n' % name)
                f.write('        warnings.warn(\'Ignoring nonzero value outside of sparsity pattern for '
                        'parameter %s!\')\n' % name)
                f.write('    par.%s = list(%s_value)\n' % (name, name))
        else:
            if size == 1:
                f.write('    par.%s = param_dict[\'%s\'].value\n' % (name, name))
            else:
                f.write('    par.%s = list(param_dict[\'%s\'].value.flatten(order=\'F\'))\n' % (name, name))

    f.write('\n    # solve\n')
    f.write('    t0 = time.time()\n')
    f.write('    res = cpg_module.solve(upd, par)\n')
    f.write('    t1 = time.time()\n\n')

    f.write('    # store solution in problem object\n')
    f.write('    prob._clear_solution()\n')
    for name, shape in variable_info.name_to_shape.items():
        if len(shape) == 2:
            f.write('    prob.var_dict[\'%s\'].save_value(np.array(res.cpg_prim.%s).reshape((%d, %d), order=\'F\'))\n' %
                    (name, name, shape[0], shape[1]))
        elif len(shape) == 1:
            f.write('    prob.var_dict[\'%s\'].save_value(np.array(res.cpg_prim.%s).reshape(%d))\n'
                    % (name, name, shape[0]))
        else:
            f.write('    prob.var_dict[\'%s\'].save_value(np.array(res.cpg_prim.%s))\n' % (name, name))
    for i, (name, shape) in enumerate(dual_variable_info.name_to_shape.items()):
        if len(shape) == 2:
            f.write('    prob.constraints[%d].save_dual_value('
                    'np.array(res.cpg_dual.%s).reshape((%d, %d), order=\'F\'))\n' % (i, name, shape[0], shape[1]))
        elif len(shape) == 1:
            f.write('    prob.constraints[%d].save_dual_value(np.array(res.cpg_dual.%s).reshape(%d))\n'
                    % (i, name, shape[0]))
        else:
            f.write('    prob.constraints[%d].save_dual_value(np.array(res.cpg_dual.%s))\n' % (i, name))

    f.write('\n    # store additional solver information in problem object\n')
    f.write('    prob._status = %sres.cpg_info.status\n' %
                (('"%%d (for description visit %s)" %% ' % solver_interface.docu) if solver_interface.status_is_int else ''))
    f.write('    if abs(res.cpg_info.obj_val) == 1e30:\n')
    f.write('        prob._value = np.sign(res.cpg_info.obj_val)*np.inf\n')
    f.write('    else:\n')
    f.write('        prob._value = res.cpg_info.obj_val\n')
    f.write('    primal_vars = {var.id: var.value for var in prob.variables()}\n')
    f.write('    dual_vars = {c.id: c.dual_value for c in prob.constraints}\n')
    f.write('    solver_specific_stats = {\'obj_val\': res.cpg_info.obj_val,\n')
    f.write('                             \'status\': prob._status,\n')
    f.write('                             \'iter\': res.cpg_info.iter,\n')
    f.write('                             \'pri_res\': res.cpg_info.pri_res,\n')
    f.write('                             \'dua_res\': res.cpg_info.dua_res,\n')
    f.write('                             \'time\': res.cpg_info.time}\n')
    f.write('    attr = {\'solve_time\': t1-t0, \'solver_specific_stats\': solver_specific_stats, '
            '\'num_iters\': res.cpg_info.iter}\n')
    f.write('    prob._solution = Solution(prob.status, prob.value, primal_vars, dual_vars, attr)\n')
    f.write('    results_dict = {\'solver_specific_stats\': solver_specific_stats,\n')
    f.write('                    \'num_iters\': res.cpg_info.iter,\n')
    f.write('                    \'solve_time\': t1-t0}\n')
    f.write('    prob._solver_stats = SolverStats(results_dict, \'%s\')\n\n' % configuration.solver_name)

    f.write('    return prob.value\n')


def replace_html_data(text, configuration, variable_info, dual_variable_info, parameter_info, solver_interface):
    """
    Replace placeholder strings in html documentation file
    """

    # description
    now = datetime.now()
    text = text.replace('$DATE', now.strftime("on %B %d, %Y at %H:%M:%S"))

    # param summary
    text = text.replace('$PARAMS', write_problem_summary(parameter_info.name_to_shape, parameter_info.name_to_size_usp))

    # primal variable summary
    text = text.replace('$PRIMALS', write_problem_summary(variable_info.name_to_shape, variable_info.name_to_size))

    # dual variable summary
    text = text.replace('$DUALS', write_problem_summary(dual_variable_info.name_to_shape, dual_variable_info.name_to_size))

    # code_dir
    text = text.replace('$CODEDIR', configuration.code_dir)
    text = text.replace('$CDPYTHON', configuration.code_dir.replace('/', '.').replace('\\', '.'))

    # solver name and docu
    text = text.replace('$CPGSOLVERNAME', configuration.solver_name)
    text = text.replace('$CPGSOLVERDOCUURL', solver_interface.docu)

    # CMake prefix
    text = text.replace('$CPGCMAKELISTS', configuration.prefix+'cpg')

    # type definition of CPG_Prim_t
    CPGPRIMTYPEDEF = '\n// Struct type with primal solution\n'
    CPGPRIMTYPEDEF += 'typedef struct {\n'
    for name, var in variable_info.name_to_init.items():
        if is_mathematical_scalar(var):
            s = ''
        else:
            s = '*'
        CPGPRIMTYPEDEF += ('  cpg_float    %s   // Your variable %s\n' % ((s + name + ';').ljust(9), name))
    CPGPRIMTYPEDEF += '} CPG_Prim_t;\n'
    text = text.replace('$CPGPRIMTYPEDEF', CPGPRIMTYPEDEF)

    # type definition of CPG_Dual_t
    if len(dual_variable_info.name_to_init) > 0:
        CPGDUALTYPEDEF = '\n// Struct type with dual solution\n'
        CPGDUALTYPEDEF += 'typedef struct {\n'
        for name, var in dual_variable_info.name_to_init.items():
            if is_mathematical_scalar(var):
                s = ''
            else:
                s = '*'
            CPGDUALTYPEDEF += ('  cpg_float    %s   // Your dual variable for constraint %s\n'
                               % ((s + name + ';').ljust(9), name))
        CPGDUALTYPEDEF += '} CPG_Dual_t;\n\n'
    else:
        CPGDUALTYPEDEF = ''
    text = text.replace('$CPGDUALTYPEDEF', CPGDUALTYPEDEF)

    # type definition of CPG_Info_t
    CPGINFOTYPEDEF = '// Struct type with canonical solver information\n'
    CPGINFOTYPEDEF += 'typedef struct {\n'
    CPGINFOTYPEDEF += '  cpg_float    obj_val;    // Objective function value\n'
    CPGINFOTYPEDEF += '  cpg_int      iter;       // Number of iterations\n'
    CPGINFOTYPEDEF += ('  %sstatus;     // Solver status\n' % ('cpg_int      ' if solver_interface.status_is_int else 'char       *'))
    CPGINFOTYPEDEF += '  cpg_float    pri_res;    // Primal residual\n'
    CPGINFOTYPEDEF += '  cpg_float    dua_res;    // Dual residual\n'
    CPGINFOTYPEDEF += '} CPG_Info_t;\n'
    text = text.replace('$CPGINFOTYPEDEF', CPGINFOTYPEDEF)

    # type definition of CPG_Result_t
    CPGRESULTTYPEDEF = '\n// Struct type with user-defined objective value and solution as fields\n'
    CPGRESULTTYPEDEF += 'typedef struct {\n'
    CPGRESULTTYPEDEF += '  CPG_Prim_t *prim;      // Primal solution\n'
    if len(dual_variable_info.name_to_init) > 0:
        CPGRESULTTYPEDEF += '  CPG_Dual_t *dual;      // Dual solution\n'
    CPGRESULTTYPEDEF += '  CPG_Info_t *info;      // Solver information\n'
    CPGRESULTTYPEDEF += '} CPG_Result_t;\n'
    text = text.replace('$CPGRESULTTYPEDEF', CPGRESULTTYPEDEF)

    # update declarations
    CPGUPDATEDECLARATIONS = '\n// Update user-defined parameter values\n'
    for name, size in parameter_info.name_to_size_usp.items():
        if size == 1:
            CPGUPDATEDECLARATIONS += 'void %scpg_update_%s(cpg_float value);\n' % (configuration.prefix, name)
        else:
            CPGUPDATEDECLARATIONS += 'void %scpg_update_%s(cpg_int idx, cpg_float value);\n' % (configuration.prefix, name)
    text = text.replace('$CPGUPDATEDECLARATIONS', CPGUPDATEDECLARATIONS)

    # solve declarations
    CPGSOLVEDECLARATIONS = '\n// Solve via canonicalization, canonical solve, retrieval\n'
    CPGSOLVEDECLARATIONS += 'void %scpg_solve();\n' % configuration.prefix
    text = text.replace('$CPGSOLVEDECLARATIONS', CPGSOLVEDECLARATIONS)

    # settings declarations
    CPGSETTINGSDECLARATIONS = '\n// Update solver settings\n'
    CPGSETTINGSDECLARATIONS += 'void %scpg_set_solver_default_settings();\n' % configuration.prefix
    CPGSETTINGSDECLARATIONS += 'void %scpg_set_solver_&lt;setting_name&gt;' \
                               '(&lt;setting_type&gt; &lt;setting_name&gt;_new);\n' % configuration.prefix
    CPGSETTINGSDECLARATIONS += '...\n'
    text = text.replace('$CPGSETTINGSDECLARATIONS', CPGSETTINGSDECLARATIONS)

    # settings list
    CPGSETTINGSLIST = ', '.join([('<code>%s</code>' % s) for s in solver_interface.stgs_names_enabled])

    return text.replace('$CPGSETTINGSLIST', CPGSETTINGSLIST)
