
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>CPG Code Documentation</title>
    <meta name="author" content="">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {background-color: white; padding-left: 260px; padding-right: 260px;}
        h1, h2, h3, h4, h5, h6   {color: darkslateblue; font-family: sans-serif;}
        p, dl {color: black; font-family: sans-serif;}
        dt, dd {margin-top: 10px;}
        code {color: black; background-color: #f1f1f1;}
        pre {background-color: #f1f1f1; padding-left: 20px; padding-right: 20px;}
    </style>
</head>

<body>
  <h1>C code to solve your CVXPY problem</h1>
  <h3>File tree</h3>
  <p>
    Your generated code is structured as follows inside your chosen <code>$CODEDIR</code> directory:
  </p>
  <pre><code><!-- language: lang-c -->
$CODEDIR
    c
      solver_code
        ...
      include
        cpg_workspace.h
        cpg_solve.h
      src
        cpg_workspace.c
        cpg_solve.c
        cpg_example.c
      build
      CMakeLists.txt
    cpp
      include
        cpg_module.hpp
      src
        cpg_module.cpp
    setup.py
    cpg_solver.py
    problem.pickle
  </code></pre>
  <p>
      The <code>c/solver_code</code> subdirectory contains all code produced by the code generation feature of the chosen
      numerical solver ($CPGSOLVERNAME). For documentation on this part, please have a look <a href="$CPGSOLVERDOCUURL" target="_blank">here</a>.
  </p>
  <p>
    To make this solver usable, your problem needs to be converted to the standard form accepted by $CPGSOLVERNAME.
      This is done by all the other source files inside the <code>$CODEDIR</code> directory.
  </p>
  <h3>Types, declarations & definitions</h3>

  <p>
    <dl>
      <dt><code>c/include/cpg_workspace.h</code> contains type definitions,</dt>
        <dd>
          <pre><code><!-- language: lang-c -->
$CPGBASICTYPEDEF
$CPGCANONPARAMSTYPEDEF
$CPGOUTDATEDTYPEDEF
$CPGUSERPARAMSTYPEDEF
// Struct containing solver info
typedef struct {
    c_float     obj_val;         ///< Objective function value
    c_int       iter;            ///< Number of iterations
    c_int       status;          ///< Solver status
    c_float     pri_res;         ///< Primal residual
    c_float     dua_res;         ///< Dual residual
} CPG_Info_t;

$CPGRESULTTYPEDEF
          </code></pre>
        </dd>
        <dd>
             and C variable declarations, where matrix parameters and variables are stored in vectorized form:
        </dd>
        <dd>
          <pre><code><!-- language: lang-c -->
$CPGEXTRADECLARATIONS
// Struct containing flags for outdated canonical parameters
Canon_Outdated_t Canon_Outdated;

$CPGCANONPARAMDECLARATIONS
$CPGCANONPARAMSTRUCTDECLARATIONS
$CPGPARAMDECLARATIONS
$CPGVARIABLEDECLARATIONS
// Struct containing solver info
CPG_Info_t CPG_Info;

// Struct containing user-defined objective value and solution
CPG_Result_t CPG_Result;
          </code></pre>
        </dd>
      <dt><code>c/include/cpg_solve.h</code> contains function prototypes:</dt>
        <dd>
          <pre><code><!-- language: lang-c -->
$CPGCANONICALIZEDECLARATIONS
// retrieve solution in terms of user-defined variables
void retrieve_solution();

// retrieve solver info
void retrieve_info();

// perform one ASA sequence to solve a problem instance
void solve();

$CPGUPDATEDECLARATIONS
// update solver settings
void set_solver_default_settings();
void set_solver_&lt;setting_name&gt;(&lt;setting_type&gt; &lt;setting_value&gt;);
...
          </code></pre>
        </dd>
        <dd>
            where <code>&lt;setting_name&gt;</code>, <code>&lt;setting_type&gt;</code>, and <code>&lt;setting_value&gt;</code> are
            the name, type, and value of the solver setting to be updated, respectively.
        </dd>
      <dt><code>c/src/cpg_workspace.c</code> contains the static allocation of the C variables declared in <code>include/cpg_workspace.h</code>.</dt>
      <dt><code>c/src/cpg_solve.c</code> contains the definition of functions declared in <code>include/cpg_solve.h</code>.</dt>
      <dt><code>c/src/cpg_example.c</code> contains example code that initializes the problem data and solves a problem instance.</dt>
      <dt><code>c/CMakeLists.txt</code> contains instructions for build file generation inside the <code>c/build</code> directory with CMake.</dt>
      <dt><code>cpp/</code> contains binding code for the python wrapper generated with <a href="https://github.com/pybind/pybind11" target="_blank">pybind11</a> and <code>setup.py</code>.</dt>
      <dt><code>cpg_solver.py</code> contains a custom CVXPY solve method that uses the python wrapper to solve your problem.</dt>
      <dt>Finally, <code>problem.pickle</code> is the serialized version of your CVXPY problem object.</dt>
    </dl>
  </p>

  <h3>Using Generated Code</h3>

  <h4>Python</h4>

  <p>
      To use the python module, run exemplarily,
  </p>
    <pre><code>
import pickle
from $CDPYTHON.cpg_solver import cpg_solve

with open('$CODEDIR/problem.pickle', 'rb') as f:
    prob = pickle.load(f)

prob.param_dict['&lt;p_name&gt;'].value = &lt;p_value&gt;
prob.register_solve('CPG', cpg_solve)

obj = prob.solve(method='CPG')
print(prob.var_dict['&lt;v_name&gt;'].value)
    </code></pre>
  <p>where <code>&lt;p_name&gt;</code> and <code>&lt;p_value&gt;</code> are parameter name and value, respectively.
  After registering <code>&lt;cpg_solve&gt;</code> as custom solve method, the problem can be solved and the objective value
  <code>obj</code> and solution in terms of variable <code>&lt;v_name&gt;</code> can be inspected.
  </p>

  <h4>Example Executable</h4>

  <p>
    To compile the example executable on a Unix platform, run the following:
  </p>
    <pre><code>
cd $CODEDIR/c/build
cmake ..
make
    </code></pre>

  <p>
    To run the example executable, type:
  </p>
    <pre><code>
$CODEDIR/c/build/cpg_example
    </code></pre>

  <h4>Existing Project</h4>

  <p>
    To use the generated code in an existing <code>CMake</code> project, copy the following to a subdirectory <code>&lt;subdir&gt;</code>
      of your project:
  </p>
    <pre><code>
$CODEDIR/c/CMakeLists.txt
$CODEDIR/c/src/
$CODEDIR/c/include/
$CODEDIR/c/solver_code/
    </code></pre>

  <p>
    In your top-level <code>CMakeLists.txt</code>, add the subdirectory via
  </p>
    <pre><code>
add_subdirectory(&lt;subdir&gt;)
include_directories(&lt;existing_dirs&gt; ${cpg_include})
    </code></pre>
  <p>
      where <code>&lt;existing_dirs&gt;</code> is your existing include directories and <code>${cpg_include}</code> lists
      the include directories used by the generated code. Add <code>${cpg_head}</code> and
      <code>${cpg_src}</code> to all targets that use the generated code.
  </p>

</body>

</html>
